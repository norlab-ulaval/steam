//////////////////////////////////////////////////////////////////////////////////////////////
/// \file LevMarqGaussNewtonSolver.hpp
///
/// \author Sean Anderson, ASRL
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef STEAM_LEVMARQ_GAUSS_NEWTON_SOLVER_HPP
#define STEAM_LEVMARQ_GAUSS_NEWTON_SOLVER_HPP

#include <Eigen/Core>

#include <steam/solver/GaussNewtonSolverBase.hpp>

namespace steam {

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Solver using Levenberg–Marquardt for the trust region
//////////////////////////////////////////////////////////////////////////////////////////////
class LevMarqGaussNewtonSolver : public GaussNewtonSolverBase
{
 public:

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Dogleg parameters
  //////////////////////////////////////////////////////////////////////////////////////////////
  struct Params : public SolverBase::Params {

    //////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    //////////////////////////////////////////////////////////////////////////////////////////////
    Params() : SolverBase::Params(), ratioThreshold(0.25),
      shrinkCoeff(0.1), growCoeff(10.0), maxShrinkSteps(50) {
    }

    /// Minimum ratio of actual to predicted reduction, shrink trust region if lower, else grow (range: 0.0-1.0)
    double ratioThreshold;

    /// Amount to shrink by (range: <1.0)
    double shrinkCoeff;

    /// Amount to grow by (range: >1.0)
    double growCoeff;

    /// Maximum number of times to shrink trust region before giving up
    unsigned int maxShrinkSteps;
  };

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Constructor
  //////////////////////////////////////////////////////////////////////////////////////////////
  LevMarqGaussNewtonSolver(OptimizationProblem* problem, const Params& params = Params());

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Solve the Levenberg–Marquardt system of equations:
  ///        A*x = b, A = (J^T*J + diagonalCoeff*diag(J^T*J))
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::VectorXd solveLevMarq(const Eigen::VectorXd& gradientVector, double diagonalCoeff);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Perform a plain LLT decomposition on the approx. Hessian matrix in
  ///        order to solve for the proper covariances (unmodified by the LM diagonal)
  //////////////////////////////////////////////////////////////////////////////////////////////
  void solveCovariances();

 private:

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Build the system, solve for a step size and direction, and update the state
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual bool linearizeSolveAndUpdate(double* newCost, double* gradNorm);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Casts parameters to base type (for SolverBase class)
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual const SolverBase::Params& getSolverBaseParams() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Parameters
  //////////////////////////////////////////////////////////////////////////////////////////////
  Params params_;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Diagonal multiplier (lambda in most papers - related to trust region size)
  //////////////////////////////////////////////////////////////////////////////////////////////
  double diagCoeff;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief The 'left-hand-side' of the Gauss-Newton problem, generally known as the
  ///        approximate Hessian matrix (note we only store the upper-triangular elements).
  ///        Note that LM stores this to later solve the plain system for covariances.
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::SparseMatrix<double> approximateHessian_;

};

} // steam

#endif // STEAM_LEVMARQ_GAUSS_NEWTON_SOLVER_HPP
