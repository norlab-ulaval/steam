//////////////////////////////////////////////////////////////////////////////////////////////
/// \file EvalTreeNode-inl.hpp
///
/// \author Sean Anderson, ASRL
//////////////////////////////////////////////////////////////////////////////////////////////

#include <steam/evaluator/blockauto/EvalTreeNode.hpp>
#include <boost/make_shared.hpp>

namespace steam {

#ifdef STEAM_USE_OBJECT_POOL
/////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Static declaration of pool type
/////////////////////////////////////////////////////////////////////////////////////////////
template<typename TYPE>
OmpPool<EvalTreeNode<TYPE> > EvalTreeNode<TYPE>::pool;
#endif

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Default constructor
//////////////////////////////////////////////////////////////////////////////////////////////
template<typename TYPE>
EvalTreeNode<TYPE>::EvalTreeNode() {
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Default constructor
//////////////////////////////////////////////////////////////////////////////////////////////
template<typename TYPE>
EvalTreeNode<TYPE>::EvalTreeNode(const TYPE& value)
  : EvalTreeNodeBase(), value_(value) {
}

#ifdef STEAM_USE_OBJECT_POOL
//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Use when node was allocated using a pool. This function causes the object to
///        release itself back to the pool it was allocated from. While the user is
///        responsible for releasing the top level node, this interface method is required
///        in order for this node to release its children.
//////////////////////////////////////////////////////////////////////////////////////////////
template<typename TYPE>
void EvalTreeNode<TYPE>::release() {
  return pool.returnObj(this);
}
#endif

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Release children and reset internals.
//////////////////////////////////////////////////////////////////////////////////////////////
template<typename TYPE>
void EvalTreeNode<TYPE>::reset() {
  // Note that we choose not to reset the value_ memory, as the whole reason we are
  // using pools is to get high efficiency, we do not want to memcpy more than once.
  EvalTreeNodeBase::reset();
}

/////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Get current value
/////////////////////////////////////////////////////////////////////////////////////////////
template<typename TYPE>
const TYPE& EvalTreeNode<TYPE>::getValue() const {
  return value_;
}

/////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Set current value
/////////////////////////////////////////////////////////////////////////////////////////////
template<typename TYPE>
void EvalTreeNode<TYPE>::setValue(const TYPE& value) {
  value_ = value;
}

} // steam
